#include "neural_interpreter.h"
#include "common.h"
#include <avr/pgmspace.h>

#define INPUT_SIZE  30
#define OUTPUT_SIZE  8

static const float W[OUTPUT_SIZE][INPUT_SIZE] PROGMEM = {
    {1.561001300811767578e+00,2.351022481918334961e+00,4.353982806205749512e-01,-2.896419763565063477e-01,7.635934948921203613e-01,1.267070174217224121e+00,2.465909719467163086e-01,1.133630990982055664e+00,5.406331419944763184e-01,9.128172993659973145e-01,9.307432174682617188e-01,1.404447674751281738e+00,9.653855562210083008e-01,2.139741897583007812e+00,9.149199724197387695e-01,8.814202249050140381e-02,4.016083478927612305e-01,1.011876165866851807e-01,-2.879210412502288818e-01,-7.095943689346313477e-01,-1.659476011991500854e-01,-3.192210197448730469e-01,1.495269238948822021e-01,-8.918319642543792725e-02,7.975728809833526611e-02,-2.433556914329528809e-01,-1.503482013940811157e-01,-4.491513371467590332e-01,-3.290676474571228027e-01,7.639009952545166016e-01},
    {-5.336468219757080078e-01,-1.359046339988708496e+00,-8.238301277160644531e-01,-1.238668084144592285e+00,-4.050283432006835938e-01,-4.581788480281829834e-01,-1.615844726562500000e+00,-8.409594297409057617e-01,-4.607818126678466797e-01,-3.323396444320678711e-01,3.425134420394897461e+00,-2.549930810928344727e-01,2.372150868177413940e-01,-4.811124503612518311e-01,-1.478222012519836426e-01,3.865044414997100830e-01,6.144527196884155273e-01,3.756575584411621094e-01,3.908839821815490723e-01,-2.147515565156936646e-01,3.753570914268493652e-01,5.106440782546997070e-01,5.045984983444213867e-01,2.143223881721496582e-01,-1.653334200382232666e-01,1.433137618005275726e-02,9.047444462776184082e-01,1.273415923118591309e+00,4.568117856979370117e-01,-1.256573915481567383e+00},
    {-6.377774477005004883e-01,-4.656550586223602295e-01,9.588664770126342773e-01,-1.282987117767333984e+00,-4.931505620479583740e-01,-3.228155970573425293e-01,3.404135942459106445e+00,5.795420408248901367e-01,-3.330892026424407959e-01,-2.983628213405609131e-01,-2.273980140686035156e+00,-5.434572100639343262e-01,-5.340301990509033203e-01,-9.619683623313903809e-01,-3.997085094451904297e-01,1.603115916252136230e+00,1.810720115900039673e-01,-3.682949244976043701e-01,1.618815958499908447e-01,2.200148552656173706e-01,7.998464107513427734e-01,7.265422940254211426e-01,2.934338748455047607e-01,6.550136804580688477e-01,-6.709008216857910156e-01,1.155849575996398926e+00,-1.336436532437801361e-02,-1.909807510673999786e-02,3.238085508346557617e-01,2.372848540544509888e-01},
    {-2.797734178602695465e-02,-1.710599958896636963e-01,-9.065125882625579834e-02,-1.684292703866958618e-01,-7.046604901552200317e-02,-5.057426542043685913e-02,-1.427838653326034546e-01,-1.253645271062850952e-01,-1.195199117064476013e-01,-8.973695337772369385e-02,-1.809597313404083252e-01,-7.960644364356994629e-02,-1.872125826776027679e-02,-6.339957565069198608e-02,-2.041653497144579887e-03,-2.400280386209487915e-01,-2.000715881586074829e-01,-1.925096213817596436e-01,-9.694944322109222412e-02,-1.683169156312942505e-01,-3.027718961238861084e-01,-2.632025182247161865e-01,-2.046751081943511963e-01,-2.233940809965133667e-01,-2.568815052509307861e-01,-2.501399815082550049e-01,-2.366695553064346313e-01,-1.721345037221908569e-01,-1.921853125095367432e-01,-1.073164790868759155e-01},
    {-2.488266825675964355e-01,-4.661964252591133118e-02,-3.986727297306060791e-01,3.375438213348388672e+00,4.847903847694396973e-01,-2.259660661220550537e-01,-1.330556631088256836e+00,-6.267257928848266602e-01,3.257755339145660400e-01,-1.044481322169303894e-01,-1.480770349502563477e+00,-2.797258198261260986e-01,-3.964324891567230225e-01,-4.692849516868591309e-01,-1.933502703905105591e-01,-1.003675103187561035e+00,-4.459994137287139893e-01,1.016201138496398926e+00,4.379196166992187500e-01,1.585805177688598633e+00,-4.569667391479015350e-03,-7.726663257926702499e-03,-3.903052583336830139e-02,4.738391563296318054e-02,1.625237703323364258e+00,1.086649671196937561e-01,3.251111209392547607e-01,-2.649660222232341766e-02,1.834906190633773804e-01,9.434555172920227051e-01},
    {-1.609660871326923370e-02,-1.445117443799972534e-01,-8.033008128404617310e-02,-1.503674387931823730e-01,-7.112169265747070312e-02,-6.010030955076217651e-02,-2.011414766311645508e-01,-5.017120391130447388e-02,4.136088537052273750e-04,-2.828460745513439178e-02,-1.800906807184219360e-01,-1.201541870832443237e-01,-4.980746284127235413e-02,-1.506395936012268066e-01,5.253301002085208893e-03,-2.724342644214630127e-01,-2.518874704837799072e-01,-2.926447391510009766e-01,-1.901285797357559204e-01,-2.034020274877548218e-01,-3.386755287647247314e-01,-2.495930790901184082e-01,-1.111240610480308533e-01,-2.140819728374481201e-01,-1.873150020837783813e-01,-2.449700534343719482e-01,-1.691353023052215576e-01,-2.385744452476501465e-01,-1.382543742656707764e-01,-1.378958374261856079e-01},
    {-7.406880706548690796e-02,-1.645131409168243408e-01,1.369445770978927612e-02,-1.028979495167732239e-01,-3.613721951842308044e-02,-5.935694649815559387e-02,-1.956111490726470947e-01,-4.420900344848632812e-02,-6.550749391317367554e-02,-4.417631402611732483e-02,-1.659803390502929688e-01,-5.651329178363084793e-03,-9.049770236015319824e-02,-8.959541469812393188e-02,2.162667078664526343e-04,-2.169875502586364746e-01,-1.592693030834197998e-01,-2.995277047157287598e-01,-1.669770628213882446e-01,-2.137146145105361938e-01,-2.390131950378417969e-01,-2.367228418588638306e-01,-2.353747934103012085e-01,-1.956518292427062988e-01,-2.334518134593963623e-01,-2.992248535156250000e-01,-2.552443444728851318e-01,-1.977820098400115967e-01,-1.571286171674728394e-01,-2.235724329948425293e-01},
    {-3.470053896307945251e-02,-1.611349880695343018e-01,-8.020920306444168091e-02,-1.212111413478851318e-01,-5.397793836891651154e-03,-6.451204419136047363e-03,-1.884770542383193970e-01,-9.510907530784606934e-02,-9.928207844495773315e-02,-9.116005897521972656e-02,-2.109665125608444214e-01,-1.391276568174362183e-01,5.121634341776371002e-03,-9.917860478162765503e-02,-3.622474148869514465e-02,-2.596226036548614502e-01,-1.511638760566711426e-01,-2.752853035926818848e-01,-2.429793179035186768e-01,-1.789091974496841431e-01,-2.636470794677734375e-01,-2.625432312488555908e-01,-2.437700629234313965e-01,-1.593251973390579224e-01,-1.972124576568603516e-01,-2.234658598899841309e-01,-3.037577569484710693e-01,-1.633467227220535278e-01,-1.135200634598731995e-01,-2.108783721923828125e-01},
};

static const float b[OUTPUT_SIZE] PROGMEM = { -1.451217979192733765e-01,5.989616513252258301e-01,6.644212007522583008e-01,-4.614155590534210205e-01,5.981521010398864746e-01,-4.149785339832305908e-01,-4.228053092956542969e-01,-4.172121882438659668e-01 };

/**
 * Calculate ranks from the input vector and store them in the output vector.
 * The computed values are actually the sorted indices, rather than usual ranks.
 *
 * Note that this function only works on arrays of size 5 for efficiency reasons.
 *
 * Example:
 *     d: [ 44,   23,   71,    9,   88 ]
 *   out: [0.75, 0.25, 0.00, 0.50, 1.00]
 */
static inline void ranks5(uint16_t *d_orig, float *out) {
    uint8_t i, j;
    out[0] = 0.0;
    out[1] = 0.25;
    out[2] = 0.50;
    out[3] = 0.75;
    out[4] = 1.0;

    uint16_t d[5];
    memcpy(&d, d_orig, sizeof(uint16_t) * 5);

    for (i = 1; i < 5; i++) {
        uint16_t tmp = d[i];
        float tmpi = out[i];
        for (j = i; j >= 1 && tmp < d[j-1]; j--) {
                d[j] = d[j-1];
                out[j] = out[j-1];
        }
        d[j] = tmp;
        out[j] = tmpi;
    }
}

static inline void preprocess(uint16_t *fhtLeft, uint16_t *fhtFront, uint16_t *fhtRight, float out[INPUT_SIZE]) {
    // Integer vector
    uint16_t val[15];

    val[0] = max(fhtLeft[LED1_BIN], max(fhtLeft[LED1_BIN-1], fhtLeft[LED1_BIN+1]));
    val[1] = max(fhtLeft[LED2_BIN], max(fhtLeft[LED2_BIN-1], fhtLeft[LED2_BIN+1]));
    val[2] = max(fhtLeft[LED3_BIN], max(fhtLeft[LED3_BIN-1], fhtLeft[LED3_BIN+1]));
    val[3] = max(fhtLeft[LED4_BIN], max(fhtLeft[LED4_BIN-1], fhtLeft[LED4_BIN+1]));
    val[4] = max(fhtLeft[LED5_BIN], max(fhtLeft[LED5_BIN-1], fhtLeft[LED5_BIN+1]));
    val[5] = max(fhtFront[LED1_BIN], max(fhtFront[LED1_BIN-1], fhtFront[LED1_BIN+1]));
    val[6] = max(fhtFront[LED2_BIN], max(fhtFront[LED2_BIN-1], fhtFront[LED2_BIN+1]));
    val[7] = max(fhtFront[LED3_BIN], max(fhtFront[LED3_BIN-1], fhtFront[LED3_BIN+1]));
    val[8] = max(fhtFront[LED4_BIN], max(fhtFront[LED4_BIN-1], fhtFront[LED4_BIN+1]));
    val[9] = max(fhtFront[LED5_BIN], max(fhtFront[LED5_BIN-1], fhtFront[LED5_BIN+1]));
    val[10] = max(fhtRight[LED1_BIN], max(fhtRight[LED1_BIN-1], fhtRight[LED1_BIN+1]));
    val[11] = max(fhtRight[LED2_BIN], max(fhtRight[LED2_BIN-1], fhtRight[LED2_BIN+1]));
    val[12] = max(fhtRight[LED3_BIN], max(fhtRight[LED3_BIN-1], fhtRight[LED3_BIN+1]));
    val[13] = max(fhtRight[LED4_BIN], max(fhtRight[LED4_BIN-1], fhtRight[LED4_BIN+1]));
    val[14] = max(fhtRight[LED5_BIN], max(fhtRight[LED5_BIN-1], fhtRight[LED5_BIN+1]));

    // Compute ranks
    ranks5(&(val[0]), &(out[15]));
    ranks5(&(val[5]), &(out[20]));
    ranks5(&(val[10]), &(out[25]));

    // Compute max
    float maxIntensity = val[0];
    for (uint8_t i = 0; i < 15; i++) {
        if (val[i] > maxIntensity) {
            maxIntensity = val[i];
        }
    }

    // Normalize intensity
    for (uint8_t i = 0; i < 15; i++) {
        out[i] = val[i] / maxIntensity;
    }
}

CrossroadStatus neuralInterpretate(uint16_t *fhtLeft, uint16_t *fhtFront, uint16_t *fhtRight) {
    // We make them static so that:
    //  1. we can be more efficient (no stack allocations)
    //  2. as they're big, we're always sure to have enough memory to hold them
    static float x[INPUT_SIZE];
    static float y[OUTPUT_SIZE];
    static float Wrow[INPUT_SIZE];

    // Fill x with the preprocessed input data
    preprocess(fhtLeft, fhtFront, fhtRight, x);

    // Initialize y = b so that we don't have to sum it later
    memcpy_P(y, &b, sizeof(float) * OUTPUT_SIZE);

    // Matrix multiplication
    for (uint8_t i = 0; i < OUTPUT_SIZE; i++) {
        // Get a row from progmem
        memcpy_P(Wrow, &(W[i]), sizeof(float) * INPUT_SIZE);
        for (uint8_t j = 0; j < INPUT_SIZE; j++) {
            y[i] += x[j] * Wrow[j];
        }
    }

    // Interpretate the result
    uint8_t maxIndex = 0;
    for (uint8_t i = 1; i < OUTPUT_SIZE; i++) {
        if (y[i] > y[maxIndex]) {
            maxIndex = i;
        }
    }

    CrossroadStatus result;
    result.left = ((maxIndex >> 2) & 1) == 1;  // maxIndex IN (4, 5, 6, 7) -> 1xx
    result.front = ((maxIndex >> 1) & 1) == 1; // maxIndex IN (2, 3, 6, 7) -> x1x
    result.right = ((maxIndex >> 0) & 1) == 1; // maxIndex IN (1, 3, 5, 7) -> xx1

    return result;
}