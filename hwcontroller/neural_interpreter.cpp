#include "neural_interpreter.h"
#include "common.h"
#include <avr/pgmspace.h>

#define INPUT_SIZE  30
#define OUTPUT_SIZE  8

static const float W[OUTPUT_SIZE][INPUT_SIZE] PROGMEM = {
    {1.522340416908264160e+00,2.516610145568847656e+00,3.852310776710510254e-01,-2.862374484539031982e-01,7.469726204872131348e-01,1.218587756156921387e+00,2.271006256341934204e-01,1.176096796989440918e+00,5.649203658103942871e-01,8.891804218292236328e-01,9.471568465232849121e-01,1.344041466712951660e+00,9.828310608863830566e-01,2.179844856262207031e+00,9.052018523216247559e-01,9.785716980695724487e-02,4.843390285968780518e-01,7.812087982892990112e-02,-1.857114434242248535e-01,-7.522008419036865234e-01,-1.350998431444168091e-01,-2.557500004768371582e-01,1.056599542498588562e-01,5.816127173602581024e-03,1.279414147138595581e-01,-1.916093230247497559e-01,-1.494887322187423706e-01,-4.095795154571533203e-01,-3.026428520679473877e-01,8.156409263610839844e-01},
    {-5.230417847633361816e-01,-1.367021679878234863e+00,-7.740765213966369629e-01,-1.267757534980773926e+00,-4.045223593711853027e-01,-5.540912151336669922e-01,-1.679508805274963379e+00,-8.328921198844909668e-01,-3.801607489585876465e-01,-3.516630232334136963e-01,3.400647401809692383e+00,-3.007104694843292236e-01,1.712844818830490112e-01,-5.329545140266418457e-01,-5.265293642878532410e-02,4.008541107177734375e-01,5.875207185745239258e-01,3.821176588535308838e-01,3.312447667121887207e-01,-3.873094618320465088e-01,4.813513159751892090e-01,4.450058043003082275e-01,4.315910935401916504e-01,2.046585828065872192e-01,-1.090399399399757385e-01,8.650990575551986694e-02,9.040425419807434082e-01,1.412030220031738281e+00,4.698025286197662354e-01,-1.308639883995056152e+00},
    {-5.881329178810119629e-01,-4.661680459976196289e-01,9.137199521064758301e-01,-1.361413955688476562e+00,-4.767331182956695557e-01,-2.299763113260269165e-01,3.348825931549072266e+00,6.145678758621215820e-01,-3.088108301162719727e-01,-2.904740571975708008e-01,-2.242794752120971680e+00,-4.945116639137268066e-01,-6.066148281097412109e-01,-9.430733919143676758e-01,-3.777705729007720947e-01,1.606995105743408203e+00,1.078079789876937866e-01,-4.167725443840026855e-01,1.656398177146911621e-01,2.268066853284835815e-01,7.388751506805419922e-01,7.406047582626342773e-01,3.068536520004272461e-01,6.801927685737609863e-01,-7.292118072509765625e-01,1.159994602203369141e+00,1.130858901888132095e-03,1.010231450200080872e-01,3.016062676906585693e-01,2.119625210762023926e-01},
    {-9.831086546182632446e-02,-1.144169494509696960e-01,-6.337181478738784790e-02,-1.013219356536865234e-01,-4.938104539178311825e-04,-8.058948069810867310e-02,-1.095544695854187012e-01,-4.086863622069358826e-02,-6.951309740543365479e-02,-8.667853474617004395e-02,-2.243407964706420898e-01,-5.258914083242416382e-02,-2.413549460470676422e-02,-2.775925910100340843e-03,-3.542018681764602661e-02,-2.976635992527008057e-01,-1.562515050172805786e-01,-2.465741187334060669e-01,-2.006146609783172607e-01,-1.890705823898315430e-01,-2.476570606231689453e-01,-1.525144428014755249e-01,-2.078598886728286743e-01,-1.141116544604301453e-01,-1.861004084348678589e-01,-2.956614494323730469e-01,-2.271599322557449341e-01,-2.292469888925552368e-01,-1.717088073492050171e-01,-1.325416564941406250e-01},
    {-1.534013003110885620e-01,-4.397980123758316040e-02,-2.763019800186157227e-01,3.368165016174316406e+00,5.244717001914978027e-01,-1.714185923337936401e-01,-1.230557203292846680e+00,-5.526189804077148438e-01,4.431003034114837646e-01,-1.068379580974578857e-01,-1.371617913246154785e+00,-2.988373935222625732e-01,-3.889300823211669922e-01,-5.525814890861511230e-01,-3.013422191143035889e-01,-1.051001667976379395e+00,-4.536479115486145020e-01,9.449499249458312988e-01,4.823448657989501953e-01,1.578245878219604492e+00,-1.143414154648780823e-02,-2.472943440079689026e-02,-1.190243735909461975e-01,7.218035310506820679e-02,1.575055956840515137e+00,1.458833813667297363e-01,3.305218517780303955e-01,-1.187480520457029343e-02,2.147972583770751953e-01,1.043563604354858398e+00},
    {-1.357921957969665527e-01,-1.212787255644798279e-01,-6.221649423241615295e-02,-6.221842393279075623e-02,-1.122481897473335266e-01,-6.051525101065635681e-02,-1.540564298629760742e-01,-9.394041448831558228e-02,-1.119952648878097534e-01,-1.981769688427448273e-02,-2.312408387660980225e-01,-1.837842632085084915e-03,-4.987594857811927795e-02,-3.396516665816307068e-02,-8.902012556791305542e-02,-1.965022534132003784e-01,-1.281872540712356567e-01,-3.053781390190124512e-01,-1.595442742109298706e-01,-2.208293825387954712e-01,-2.736238837242126465e-01,-2.447590827941894531e-01,-2.222749292850494385e-01,-1.577216535806655884e-01,-2.020207643508911133e-01,-2.686164677143096924e-01,-2.728637158870697021e-01,-1.641850769519805908e-01,-2.379269301891326904e-01,-1.286176145076751709e-01},
    {2.009984478354454041e-02,-1.607913076877593994e-01,-3.362753614783287048e-02,-1.621992141008377075e-01,-3.617790061980485916e-03,2.411256544291973114e-03,-1.701272577047348022e-01,-9.367085248231887817e-02,-1.144309341907501221e-01,-2.893761359155178070e-02,-2.218969613313674927e-01,1.800050958991050720e-02,-1.131938323378562927e-01,-4.693890362977981567e-02,-2.721718698740005493e-02,-2.584182322025299072e-01,-1.923608481884002686e-01,-2.815874814987182617e-01,-1.545917391777038574e-01,-2.070031017065048218e-01,-2.655749619007110596e-01,-2.166309952735900879e-01,-2.451959550380706787e-01,-1.857273727655410767e-01,-2.036582380533218384e-01,-2.321606129407882690e-01,-1.978026926517486572e-01,-1.705459654331207275e-01,-2.045204937458038330e-01,-1.322344392538070679e-01},
    {-6.642395257949829102e-02,-1.131676062941551208e-01,-2.871637977659702301e-02,-1.396819055080413818e-01,-1.533696614205837250e-02,-6.446111947298049927e-02,-1.289093643426895142e-01,-5.683880671858787537e-02,-4.436906054615974426e-02,-8.436796069145202637e-02,-1.982067227363586426e-01,-1.100387722253799438e-01,-2.038571983575820923e-02,-6.710203737020492554e-02,5.090991500765085220e-03,-2.460651695728302002e-01,-2.259241491556167603e-01,-2.885099351406097412e-01,-1.038123071193695068e-01,-2.585853040218353271e-01,-2.908933460712432861e-01,-2.002158612012863159e-01,-2.072831541299819946e-01,-1.800330430269241333e-01,-1.688445061445236206e-01,-2.178287655115127563e-01,-2.671548724174499512e-01,-2.051610201597213745e-01,-1.623739600181579590e-01,-1.664394885301589966e-01},
};

static const float b[OUTPUT_SIZE] PROGMEM = { -1.017596721649169922e-01,5.504381656646728516e-01,6.566089391708374023e-01,-4.639548957347869873e-01,5.891178250312805176e-01,-4.020145535469055176e-01,-4.132084548473358154e-01,-4.152252972126007080e-01 };

/**
 * Calculate ranks from the input vector and store them in the output vector.
 * The computed values are actually the sorted indices, rather than usual ranks.
 *
 * Note that this function only works on arrays of size 5 for efficiency reasons.
 *
 * Example:
 *     d: [ 44,   23,   71,    9,   88 ]
 *   out: [0.75, 0.25, 0.00, 0.50, 1.00]
 */
static inline void ranks5(uint16_t *d_orig, float *out) {
    uint8_t i, j;
    out[0] = 0.0;
    out[1] = 0.25;
    out[2] = 0.50;
    out[3] = 0.75;
    out[4] = 1.0;

    uint16_t d[5];
    memcpy(&d, d_orig, sizeof(uint16_t) * 5);

    for (i = 1; i < 5; i++) {
        uint16_t tmp = d[i];
        float tmpi = out[i];
        for (j = i; j >= 1 && tmp < d[j-1]; j--) {
                d[j] = d[j-1];
                out[j] = out[j-1];
        }
        d[j] = tmp;
        out[j] = tmpi;
    }
}

static inline void preprocess(uint16_t *fhtLeft, uint16_t *fhtFront, uint16_t *fhtRight, float out[INPUT_SIZE]) {
    // Integer vector
    uint16_t val[15];

    val[0] = max(fhtLeft[LED1_BIN], max(fhtLeft[LED1_BIN-1], fhtLeft[LED1_BIN+1]));
    val[1] = max(fhtLeft[LED2_BIN], max(fhtLeft[LED2_BIN-1], fhtLeft[LED2_BIN+1]));
    val[2] = max(fhtLeft[LED3_BIN], max(fhtLeft[LED3_BIN-1], fhtLeft[LED3_BIN+1]));
    val[3] = max(fhtLeft[LED4_BIN], max(fhtLeft[LED4_BIN-1], fhtLeft[LED4_BIN+1]));
    val[4] = max(fhtLeft[LED5_BIN], max(fhtLeft[LED5_BIN-1], fhtLeft[LED5_BIN+1]));
    val[5] = max(fhtFront[LED1_BIN], max(fhtFront[LED1_BIN-1], fhtFront[LED1_BIN+1]));
    val[6] = max(fhtFront[LED2_BIN], max(fhtFront[LED2_BIN-1], fhtFront[LED2_BIN+1]));
    val[7] = max(fhtFront[LED3_BIN], max(fhtFront[LED3_BIN-1], fhtFront[LED3_BIN+1]));
    val[8] = max(fhtFront[LED4_BIN], max(fhtFront[LED4_BIN-1], fhtFront[LED4_BIN+1]));
    val[9] = max(fhtFront[LED5_BIN], max(fhtFront[LED5_BIN-1], fhtFront[LED5_BIN+1]));
    val[10] = max(fhtRight[LED1_BIN], max(fhtRight[LED1_BIN-1], fhtRight[LED1_BIN+1]));
    val[11] = max(fhtRight[LED2_BIN], max(fhtRight[LED2_BIN-1], fhtRight[LED2_BIN+1]));
    val[12] = max(fhtRight[LED3_BIN], max(fhtRight[LED3_BIN-1], fhtRight[LED3_BIN+1]));
    val[13] = max(fhtRight[LED4_BIN], max(fhtRight[LED4_BIN-1], fhtRight[LED4_BIN+1]));
    val[14] = max(fhtRight[LED5_BIN], max(fhtRight[LED5_BIN-1], fhtRight[LED5_BIN+1]));

    // Compute ranks
    ranks5(&(val[0]), &(out[15]));
    ranks5(&(val[5]), &(out[20]));
    ranks5(&(val[10]), &(out[25]));

    // Compute max
    float maxIntensity = val[0];
    for (uint8_t i = 0; i < 15; i++) {
        if (val[i] > maxIntensity) {
            maxIntensity = val[i];
        }
    }

    // Normalize intensity
    for (uint8_t i = 0; i < 15; i++) {
        out[i] = val[i] / maxIntensity;
    }
}

CrossroadStatus neuralInterpretate(uint16_t *fhtLeft, uint16_t *fhtFront, uint16_t *fhtRight) {
    // We make them static so that:
    //  1. we can be more efficient (no stack allocations)
    //  2. as they're big, we're always sure to have enough memory to hold them
    static float x[INPUT_SIZE];
    static float y[OUTPUT_SIZE];
    static float Wrow[INPUT_SIZE];

    // Fill x with the preprocessed input data
    preprocess(fhtLeft, fhtFront, fhtRight, x);

    // Initialize y = b so that we don't have to sum it later
    memcpy_P(y, &b, sizeof(float) * OUTPUT_SIZE);

    // Matrix multiplication
    for (uint8_t i = 0; i < OUTPUT_SIZE; i++) {
        // Get a row from progmem
        memcpy_P(Wrow, &(W[i]), sizeof(float) * INPUT_SIZE);
        for (uint8_t j = 0; j < INPUT_SIZE; j++) {
            y[i] += x[j] * Wrow[j];
        }
    }

    // Interpretate the result
    uint8_t maxIndex = 0;
    for (uint8_t i = 1; i < OUTPUT_SIZE; i++) {
        if (y[i] > y[maxIndex]) {
            maxIndex = i;
        }
    }

    CrossroadStatus result;
    result.left = ((maxIndex >> 2) & 1) == 1;  // maxIndex IN (4, 5, 6, 7) -> 1xx
    result.front = ((maxIndex >> 1) & 1) == 1; // maxIndex IN (2, 3, 6, 7) -> x1x
    result.right = ((maxIndex >> 0) & 1) == 1; // maxIndex IN (1, 3, 5, 7) -> xx1

    return result;
}