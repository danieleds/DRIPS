#include "neural_interpreter.h"
#include "common.h"
#include <avr/pgmspace.h>

#define INPUT_SIZE  30
#define OUTPUT_SIZE  8

static const float W[OUTPUT_SIZE][INPUT_SIZE] PROGMEM = {
    {3.478150606155395508e+00,4.368739128112792969e+00,9.278411865234375000e-01,-2.485634535551071167e-01,1.912302851676940918e+00,7.513137459754943848e-01,7.352316379547119141e-01,9.056302309036254883e-01,3.863105475902557373e-01,5.664140582084655762e-01,9.617339372634887695e-01,7.916135787963867188e-01,6.118112802505493164e-01,1.124158382415771484e+00,4.987111389636993408e-01,2.354148477315902710e-01,8.863892555236816406e-01,1.195662245154380798e-01,9.178310632705688477e-02,-1.016628265380859375e+00,-2.024618685245513916e-01,-3.190437257289886475e-01,4.821742475032806396e-01,-8.221208304166793823e-02,4.802997708320617676e-01,-6.870500743389129639e-02,-2.503243684768676758e-01,-4.356579780578613281e-01,-4.147194921970367432e-01,1.619473934173583984e+00},
    {-8.846967816352844238e-01,-2.863999605178833008e+00,-1.690882802009582520e+00,-2.030002832412719727e+00,-6.717588305473327637e-01,-1.360647231340408325e-01,-2.018544077873229980e-01,-1.968368738889694214e-01,-1.688464172184467316e-02,-9.697476029396057129e-02,-7.854498922824859619e-02,-1.685238331556320190e-01,-6.159396469593048096e-02,-1.606067121028900146e-01,-1.566837728023529053e-01,-1.057884842157363892e-01,1.097596883773803711e+00,9.940916299819946289e-01,4.259653389453887939e-01,-5.295064449310302734e-01,5.402251482009887695e-01,7.762854695320129395e-01,4.987062513828277588e-01,-2.207005023956298828e-02,1.981963403522968292e-02,-5.497753620147705078e-01,2.292708158493041992e+00,2.649246692657470703e+00,1.292211294174194336e+00,-3.796752452850341797e+00},
    {-1.563971519470214844e+00,-4.462653994560241699e-01,1.536736607551574707e+00,-1.801576018333435059e+00,-1.261221289634704590e+00,-3.681111037731170654e-01,-3.200671672821044922e-01,-3.652497529983520508e-01,-2.506180405616760254e-01,-2.458291351795196533e-01,-5.747282505035400391e-01,-3.233810067176818848e-01,-2.780718803405761719e-01,-5.342569351196289062e-01,-1.965742409229278564e-01,2.715717315673828125e+00,-2.850374579429626465e-01,-7.761677503585815430e-01,5.190589278936386108e-02,3.461921513080596924e-01,1.171811819076538086e+00,7.402222156524658203e-01,4.244961142539978027e-01,1.026176214218139648e+00,-1.426893234252929688e+00,2.035286664962768555e+00,-1.160403132438659668e+00,-8.706811070442199707e-01,-1.027483791112899780e-01,2.093743324279785156e+00},
    {-3.814547881484031677e-02,-9.699312597513198853e-02,-3.179729357361793518e-02,-1.334795653820037842e-01,-1.361604183912277222e-01,4.002712666988372803e-02,5.197428539395332336e-02,3.348377719521522522e-02,1.794175594113767147e-03,4.750120267271995544e-02,-4.959331825375556946e-02,-4.315393790602684021e-02,7.043349742889404297e-02,4.434854164719581604e-02,2.291983552277088165e-02,-3.536238074302673340e-01,-1.884974092245101929e-01,-2.612768411636352539e-01,-2.051663696765899658e-01,-2.217159718275070190e-01,-2.720963060855865479e-01,-2.373094856739044189e-01,-3.019285500049591064e-01,-2.487082332372665405e-01,-2.717039585113525391e-01,-3.751792609691619873e-01,-3.353184759616851807e-01,-2.238501608371734619e-01,-1.202973052859306335e-01,-1.604361683130264282e-01},
    {-6.986585259437561035e-01,-3.787084519863128662e-01,-5.153437256813049316e-01,4.764072895050048828e+00,3.649839758872985840e-01,-1.786765158176422119e-01,-2.141525745391845703e-01,-1.579212844371795654e-01,-8.464761823415756226e-02,-1.635047644376754761e-01,-2.452812343835830688e-01,-2.662937343120574951e-01,-1.731824278831481934e-01,-2.870768606662750244e-01,-1.886265575885772705e-01,-1.558776378631591797e+00,-7.835541367530822754e-01,8.915206789970397949e-01,3.260078132152557373e-01,1.964923739433288574e+00,-1.839534342288970947e-01,-2.122383862733840942e-01,-4.030333459377288818e-01,-1.767093390226364136e-01,1.877976059913635254e+00,-2.651894092559814453e-01,1.576112359762191772e-01,-2.921974062919616699e-01,9.640236198902130127e-02,1.025095462799072266e+00},
    {-1.123161092400550842e-01,-1.980169564485549927e-01,-1.039179712533950806e-01,-1.054939255118370056e-01,-1.043643876910209656e-01,-7.952304929494857788e-02,-7.438330445438623428e-03,-6.608100980520248413e-02,-1.186453620903193951e-03,3.736632317304611206e-02,-7.317105308175086975e-03,-3.343763202428817749e-02,-9.377326071262359619e-02,-7.272145897150039673e-02,7.668212801218032837e-02,-3.002608418464660645e-01,-2.102081030607223511e-01,-2.316929399967193604e-01,-1.744991540908813477e-01,-2.347779273986816406e-01,-3.242326974868774414e-01,-2.652206718921661377e-01,-2.428621947765350342e-01,-2.709253132343292236e-01,-2.220754176378250122e-01,-2.984507977962493896e-01,-3.152247071266174316e-01,-2.504442632198333740e-01,-2.173167467117309570e-01,-1.706621050834655762e-01},
    {-1.340644806623458862e-02,-1.609701365232467651e-01,-8.349952846765518188e-02,-1.699333786964416504e-01,-5.847316607832908630e-02,3.551928699016571045e-02,6.087521091103553772e-02,-6.150973960757255554e-02,-2.128182910382747650e-02,-4.854829981923103333e-02,-2.531742863357067108e-02,-2.594936452805995941e-02,-5.642792209982872009e-02,-2.363212406635284424e-02,-6.962577346712350845e-03,-3.196352720260620117e-01,-2.420448958873748779e-01,-3.284311592578887939e-01,-2.119380384683609009e-01,-1.278095245361328125e-01,-3.103817999362945557e-01,-2.575469911098480225e-01,-2.406378835439682007e-01,-2.431707829236984253e-01,-2.557332813739776611e-01,-3.190592825412750244e-01,-2.502129077911376953e-01,-2.204803526401519775e-01,-1.678582727909088135e-01,-2.343157380819320679e-01},
    {-9.856770932674407959e-02,-1.722772270441055298e-01,-7.559902220964431763e-02,-1.954405754804611206e-01,-1.456235498189926147e-01,-5.923439934849739075e-02,-2.723842859268188477e-02,2.089167386293411255e-02,-5.364470183849334717e-02,-6.299866735935211182e-02,-5.411498248577117920e-02,4.236966371536254883e-02,-4.139805212616920471e-02,-3.988064825534820557e-02,3.987057134509086609e-02,-3.634953498840332031e-01,-1.840800195932388306e-01,-3.166159987449645996e-01,-2.094852775335311890e-01,-1.670965999364852905e-01,-2.350378781557083130e-01,-2.421968430280685425e-01,-1.917279809713363647e-01,-1.974437534809112549e-01,-1.859970390796661377e-01,-3.124273419380187988e-01,-2.919401824474334717e-01,-2.166352570056915283e-01,-2.247798293828964233e-01,-2.388546615839004517e-01},
};

static const float b[OUTPUT_SIZE] PROGMEM = { 1.487587988376617432e-01,7.539573907852172852e-01,8.142020702362060547e-01,-4.927708804607391357e-01,3.001288771629333496e-01,-4.929659962654113770e-01,-4.993303418159484863e-01,-5.319805741310119629e-01 };

/**
 * Calculate ranks from the input vector and store them in the output vector.
 * The computed values are actually the sorted indices, rather than usual ranks.
 *
 * Note that this function only works on arrays of size 5 for efficiency reasons.
 *
 * Example:
 *     d: [ 44,   23,   71,    9,   88 ]
 *   out: [0.75, 0.25, 0.00, 0.50, 1.00]
 */
static inline void ranks5(uint16_t *d_orig, float *out) {
    uint8_t i, j;
    out[0] = 0.0;
    out[1] = 0.25;
    out[2] = 0.50;
    out[3] = 0.75;
    out[4] = 1.0;

    uint16_t d[5];
    memcpy(&d, d_orig, sizeof(uint16_t) * 5);

    for (i = 1; i < 5; i++) {
        uint16_t tmp = d[i];
        float tmpi = out[i];
        for (j = i; j >= 1 && tmp < d[j-1]; j--) {
                d[j] = d[j-1];
                out[j] = out[j-1];
        }
        d[j] = tmp;
        out[j] = tmpi;
    }
}

static inline void preprocess(uint16_t *fhtLeft, uint16_t *fhtFront, uint16_t *fhtRight, float out[INPUT_SIZE]) {
    // Integer vector
    uint16_t val[15];

    val[0] = max(fhtLeft[LED1_BIN], max(fhtLeft[LED1_BIN-1], fhtLeft[LED1_BIN+1]));
    val[1] = max(fhtLeft[LED2_BIN], max(fhtLeft[LED2_BIN-1], fhtLeft[LED2_BIN+1]));
    val[2] = max(fhtLeft[LED3_BIN], max(fhtLeft[LED3_BIN-1], fhtLeft[LED3_BIN+1]));
    val[3] = max(fhtLeft[LED4_BIN], max(fhtLeft[LED4_BIN-1], fhtLeft[LED4_BIN+1]));
    val[4] = max(fhtLeft[LED5_BIN], max(fhtLeft[LED5_BIN-1], fhtLeft[LED5_BIN+1]));
    val[5] = max(fhtFront[LED1_BIN], max(fhtFront[LED1_BIN-1], fhtFront[LED1_BIN+1]));
    val[6] = max(fhtFront[LED2_BIN], max(fhtFront[LED2_BIN-1], fhtFront[LED2_BIN+1]));
    val[7] = max(fhtFront[LED3_BIN], max(fhtFront[LED3_BIN-1], fhtFront[LED3_BIN+1]));
    val[8] = max(fhtFront[LED4_BIN], max(fhtFront[LED4_BIN-1], fhtFront[LED4_BIN+1]));
    val[9] = max(fhtFront[LED5_BIN], max(fhtFront[LED5_BIN-1], fhtFront[LED5_BIN+1]));
    val[10] = max(fhtRight[LED1_BIN], max(fhtRight[LED1_BIN-1], fhtRight[LED1_BIN+1]));
    val[11] = max(fhtRight[LED2_BIN], max(fhtRight[LED2_BIN-1], fhtRight[LED2_BIN+1]));
    val[12] = max(fhtRight[LED3_BIN], max(fhtRight[LED3_BIN-1], fhtRight[LED3_BIN+1]));
    val[13] = max(fhtRight[LED4_BIN], max(fhtRight[LED4_BIN-1], fhtRight[LED4_BIN+1]));
    val[14] = max(fhtRight[LED5_BIN], max(fhtRight[LED5_BIN-1], fhtRight[LED5_BIN+1]));

    // Compute ranks
    ranks5(&(val[0]), &(out[15]));
    ranks5(&(val[5]), &(out[20]));
    ranks5(&(val[10]), &(out[25]));

    // Compute max
    float maxIntensity = val[0];
    for (uint8_t i = 0; i < 15; i++) {
        if (val[i] > maxIntensity) {
            maxIntensity = val[i];
        }
    }

    // Normalize intensity
    for (uint8_t i = 0; i < 15; i++) {
        out[i] = val[i] / maxIntensity;
    }
}

CrossroadStatus neuralInterpretate(uint16_t *fhtLeft, uint16_t *fhtFront, uint16_t *fhtRight) {
    // We make them static so that:
    //  1. we can be more efficient (no stack allocations)
    //  2. as they're big, we're always sure to have enough memory to hold them
    static float x[INPUT_SIZE];
    static float y[OUTPUT_SIZE];
    static float Wrow[INPUT_SIZE];

    // Fill x with the preprocessed input data
    preprocess(fhtLeft, fhtFront, fhtRight, x);

    // Initialize y = b so that we don't have to sum it later
    memcpy_P(y, &b, sizeof(float) * OUTPUT_SIZE);

    // Matrix multiplication
    for (uint8_t i = 0; i < OUTPUT_SIZE; i++) {
        // Get a row from progmem
        memcpy_P(Wrow, &(W[i]), sizeof(float) * INPUT_SIZE);
        for (uint8_t j = 0; j < INPUT_SIZE; j++) {
            y[i] += x[j] * Wrow[j];
        }
    }

    // Interpretate the result
    uint8_t maxIndex = 0;
    for (uint8_t i = 1; i < OUTPUT_SIZE; i++) {
        if (y[i] > y[maxIndex]) {
            maxIndex = i;
        }
    }

    CrossroadStatus result;
    result.left = ((maxIndex >> 2) & 1) == 1;  // maxIndex IN (4, 5, 6, 7) -> 1xx
    result.front = ((maxIndex >> 1) & 1) == 1; // maxIndex IN (2, 3, 6, 7) -> x1x
    result.right = ((maxIndex >> 0) & 1) == 1; // maxIndex IN (1, 3, 5, 7) -> xx1

    return result;
}